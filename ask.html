<!DOCTYPE html>

<html lang="en">
<head>
<!--
    PAW Embed Guard (required):
    These tool pages are built for Circle embedding.
    If someone opens this page directly (not in an iframe), redirect to proagentworks.com.
    Keep this lightweight; no dependencies.
  -->
<script>
    (function () {
      try {
        if (window.top === window.self) {
          window.location.replace("https://proagentworks.com");
        }
      } catch (e) {
        // If cross-origin framing prevents access to window.top, fail closed.
        window.location.replace("https://proagentworks.com");
      }
    })();
  </script><script>    // PAW Embed Mode Guard (Assistant)
    // -------------------------------
    // Circle provides the outer card. When embedded, we must render "flat"
    // using paw-ui.css rules that activate when html[data-embed="1"] is present.
    (function(){
      try{
        var params = new URLSearchParams(window.location.search);
        var isEmbedParam = params.get('embed') === '1';
        var isInIframe = (function(){ try{ return window.self !== window.top; } catch(e){ return true; } })();
        if(isEmbedParam || isInIframe){
          document.documentElement.setAttribute('data-embed','1');
        }
      }catch(e){}
    })();</script>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Assistant</title>
<!--
    NOTE: paw-ui.css is SHARED across tools.
    Keep header markup consistent:
    panel-topbar > topbar-row0 > tool-head + topbar-right (utility-pair).
    Changing shared classes affects multiple tools.
  -->
<link href="./paw-ui.css" rel="stylesheet"/>
</head>
<body class="paw-ask">
<div class="app">
<div class="frame">
<div class="panel">
<div class="panel-topbar">
<div class="topbar-row0">
<div class="tool-head">
<button aria-label="Work context" class="paw-mystuff-btn paw-works-btn" id="pawMyStuffBtn" type="button">
<img alt="" aria-hidden="true" class="works-paw" src="https://paw-tools.pages.dev/paw.png"/>
<span class="works-label">Work: Ready</span>
<span aria-hidden="true" class="works-chevron">▾</span>
</button>
</div>
<div class="topbar-right">
<div aria-label="Tool utilities" class="utility-pair paw-seg" role="group">
<button class="util-btn paw-seg__btn" id="reset" type="button">Reset</button>
<button class="util-btn paw-seg__btn" id="tips" type="button">Tips &amp; How To</button>
</div>
</div>
</div>
</div>
<div class="messages" id="messages"></div>
<div class="composer">
<div class="composer-main">
<div class="composer-help">Ask anything, or paste text to rewrite.</div>
<textarea id="input" placeholder="Example: Rewrite this to sound confident and warm"></textarea>
</div>
<button aria-label="Send" class="send" id="send" type="button">
<img alt="" class="send-icon" src="https://paw-tools.pages.dev/paw.png"/>
</button>
</div>
</div>
</div>
</div>
<!-- Resume Draft Modal (Assistant tool) -->
<div aria-hidden="true" class="modal" id="pawResumeModal">
<div aria-labelledby="pawResumeTitle" aria-modal="true" class="modal-card" role="dialog">
<div class="modal-head">
<div class="modal-title" id="pawResumeTitle">Resume draft?</div>
<button aria-label="Close" class="modal-close" id="pawResumeClose" type="button">✕</button>
</div>
<div class="modal-body">
<div id="pawResumeMeta" style="font-size:14px; color:rgba(15,23,42,.86); line-height:1.45; margin-bottom:14px;">
          We found a saved draft on this device.
        </div>
<div style="display:flex; gap:10px; justify-content:flex-end;">
<button class="btn" id="pawResumeFresh" type="button">Start fresh</button>
<button class="btn primary" id="pawResumeGo" type="button">Resume</button>
</div>
</div>
</div>
</div>
<script src="https://paw-tools.pages.dev/tool-shell.js"></script>
<script>
    (function () {
      const API_ENDPOINT = "https://paw-api.joe-b40.workers.dev";

      const DISCLAIMER_TEXT =
        "Important: This assistant provides guidance intended to support your work. It is not brokerage policy guidance, legal advice, and compliance cannot be guaranteed.";

      const DISCLAIMER_TRIGGER =
        /(fair housing|mls|compliance|legal|law|attorney|contract|offer|addendum|inspection|lien|title|short sale|agency|disclosure)/i;

      const TIPS_TEXT =
`What to paste
• A question you want answered
• An email, text, or draft you want rewritten
• A situation + what you want to happen next

Best results when you include
• Who it’s for (lead, buyer, seller, past client)
• The goal (book a call, set a showing, handle an objection)
• Tone (shorter, warmer, more direct)

Examples
• “Rewrite this text to sound confident and friendly…”
• “Give me 3 replies to this objection: …”`;

      const shell = window.PAWToolShell.init({
        apiEndpoint: API_ENDPOINT,
        toolId: "assistant",
        inputPlaceholder: "e.g., Rewrite this to sound confident and friendly",
        tipsText: TIPS_TEXT,

        // One-time compliance note (shown only when trigger words appear in the user message)
        complianceNoteText: DISCLAIMER_TEXT,
        complianceTrigger: DISCLAIMER_TRIGGER,

        sendHistoryItems: 10,
        maxHistoryItems: 20,
        deliverableMode: false
      });

      // ==========================================================
      // Local Save + Resume (Assistant tool)
      // ----------------------------------------------------------
      // Same contract as Listing:
      // - localStorage only, never silent restore
      // - Reset / Start fresh deletes the draft and wipes UI
      // ==========================================================

      const DRAFT_KEY = "paw:assistant:draft:v1";

      // Draft safety caps (localStorage is limited; large pastes can exceed quotas)
      const MAX_DRAFT_INPUT_CHARS = 50000;
      const MAX_DRAFT_HISTORY_ITEMS = 30;
      const MAX_DRAFT_SHELL_INPUT_CHARS = 8000;

      function trunc(s, max){
        s = (s == null) ? "" : String(s);
        if (!max || max <= 0) return "";
        return s.length > max ? s.slice(0, max) : s;
      }


      const $resumeModal = document.getElementById("pawResumeModal");
      const $resumeClose = document.getElementById("pawResumeClose");
      const $resumeMeta = document.getElementById("pawResumeMeta");
      const $resumeFresh = document.getElementById("pawResumeFresh");
      const $resumeGo = document.getElementById("pawResumeGo");

      function storageGet(key){
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return null;
          return JSON.parse(raw);
        } catch (_) { return null; }
      }
      function storageSet(key, val){
        try { localStorage.setItem(key, JSON.stringify(val)); return true; } catch (_) { return false; }
      }
      function storageDel(key){
        try { localStorage.removeItem(key); return true; } catch (_) { return false; }
      }

      let __draftSaveT = null;
      let __draftSaveFailWarned = false; // prevent repeated toasts

      function scheduleDraftSave(){
        try {
          if (__draftSaveT) clearTimeout(__draftSaveT);
          __draftSaveT = setTimeout(saveDraftNow, 350);
        } catch (_) {}
      }

      function saveDraftNow(){
        try {
          const rawShellState = (shell && shell.getState) ? shell.getState() : { history: [], input: "" };
          const st = {
            history: Array.isArray(rawShellState.history) ? rawShellState.history.slice(-MAX_DRAFT_HISTORY_ITEMS) : [],
            input: trunc(rawShellState.input, MAX_DRAFT_SHELL_INPUT_CHARS)
          };
          const hasAny = (st.input && st.input.trim()) || (Array.isArray(st.history) && st.history.length);
          if (!hasAny) { storageDel(DRAFT_KEY); return; }

          const ok = storageSet(DRAFT_KEY, {
            v: 1,
            updatedAt: new Date().toISOString(),
            toolId: "assistant",
            shell: st
          });
          if (!ok && !__draftSaveFailWarned) {
            __draftSaveFailWarned = true;
            try { if (shell && shell.toast) shell.toast("Draft couldn’t be saved on this device/browser."); } catch (_) {}
          }

        } catch (_) {}
      }

      function openResumeModal(draft){
        try {
          if (!$resumeModal) return;
          const d = draft || {};
          const ts = d.updatedAt ? new Date(d.updatedAt) : null;
          const when = ts && !isNaN(ts.getTime()) ? ts.toLocaleString() : "";
          $resumeMeta.textContent = `We found a saved draft on this device.` + (when ? ` Last saved: ${when}.` : "");

          $resumeModal.classList.add("show");
          $resumeModal.setAttribute("aria-hidden", "false");
        } catch (_) {}
      }
      function closeResumeModal(){
        try {
          if (!$resumeModal) return;
          $resumeModal.classList.remove("show");
          $resumeModal.setAttribute("aria-hidden", "true");
        } catch (_) {}
      }

      function fullReset(){
        try { storageDel(DRAFT_KEY); } catch (_) {}
        closeResumeModal();
        try { if (shell && shell.reset) shell.reset(); } catch (_) {}
      }

      // Intercept Reset so we can guarantee draft deletion.
      try {
        const $reset = document.getElementById("reset");
        if ($reset) {
          $reset.addEventListener("click", (e) => {
            try { e.preventDefault(); e.stopImmediatePropagation(); } catch (_) {}
            try {
              const rawShellState = (shell && shell.getState) ? shell.getState() : { history: [], input: "" };
              const hasAny =
                (rawShellState && Array.isArray(rawShellState.history) && rawShellState.history.length) ||
                (rawShellState && typeof rawShellState.input === "string" && rawShellState.input.trim().length);
              if (hasAny) {
                const ok = window.confirm("Reset will clear this session and start fresh. Continue?");
                if (!ok) return;
              }
            } catch (_) {}
            fullReset();
          }, true);
        }
      } catch (_) {}

      // Autosave on composer input changes
      try {
        const $input = document.getElementById("input") || document.getElementById("prompt");
        if ($input) {
          $input.addEventListener("input", scheduleDraftSave);
          $input.addEventListener("change", scheduleDraftSave);
        }
      } catch (_) {}

      window.addEventListener("beforeunload", () => { try { saveDraftNow(); } catch (_) {} });

      // Resume controls
      try { if ($resumeClose) $resumeClose.addEventListener("click", () => closeResumeModal()); } catch (_) {}
      try {
        if ($resumeModal) $resumeModal.addEventListener("click", (e) => { if (e.target === $resumeModal) closeResumeModal(); });
      } catch (_) {}
      document.addEventListener("keydown", (e) => { if (e.key === "Escape") { closeResumeModal(); } });

      try {
        if ($resumeFresh) $resumeFresh.addEventListener("click", () => {
          closeResumeModal();
          fullReset();
        });
      } catch (_) {}

      try {
        if ($resumeGo) $resumeGo.addEventListener("click", () => {
          const d = storageGet(DRAFT_KEY);
          closeResumeModal();
          if (d && d.shell && shell && shell.setState) shell.setState(d.shell);
        });
      } catch (_) {}

      // On load: show resume prompt (never silent restore)
      const existingDraft = storageGet(DRAFT_KEY);
      if (existingDraft) openResumeModal(existingDraft);

    })();
  </script>
<script>
/**
 * PAW Iframe Height Reporter (v1.1 - content-based)
 * ------------------------------------------------------------
 * Fix for "infinite growth" loops:
 * Some embed CSS patterns use min-height: 100vh (or similar) on the tool container.
 * When the parent increases iframe height, the iframe viewport grows, which increases 100vh,
 * which increases the container height, which we would re-measure as "more content" and
 * report again — causing runaway scrolling.
 *
 * This version measures the *content stack* (topbar + messages scrollHeight + composer)
 * instead of document/body height, so viewport-driven min-heights won't create feedback loops.
 *
 * Contract (unchanged):
 * - Sends: { type: "paw_iframe_height_request_v1", height: <number> }
 * - Parent decides how to clamp/apply (desktop vs mobile).
 */
(function () {
  if (window.__PAW_HEIGHT_REPORTER__) return;
  window.__PAW_HEIGHT_REPORTER__ = true;

  var lastSent = 0;
  var rafPending = false;

  // Ignore tiny oscillations
  var IGNORE_DELTA_PX = 12;

  function px(n){
    n = Number(n);
    return (isFinite(n) && n > 0) ? n : 0;
  }

  function getStackHeight() {
    try {
      var panel = document.querySelector(".panel");
      var topbar = panel ? panel.querySelector(".panel-topbar") : null;
      var messages = document.getElementById("messages");
      var composer = document.querySelector(".composer");

      // Base stack: topbar + composer + messages content height (scrollHeight reflects content, not viewport)
      var h =
        px(topbar ? topbar.offsetHeight : 0) +
        px(composer ? composer.offsetHeight : 0) +
        px(messages ? messages.scrollHeight : 0);

      // Add a small safety buffer for borders/padding that aren't captured above
      h += 24;

      // Fallback: if we can't find expected nodes, revert to robust document measurement.
      if (!h || h < 200) {
        var d = document.documentElement;
        var b = document.body;
        h = Math.max(
          px(d && d.scrollHeight),
          px(b && b.scrollHeight),
          px(d && d.offsetHeight),
          px(b && b.offsetHeight)
        );
      }

      return h;
    } catch (_) {
      return 0;
    }
  }

  function postHeight(force) {
    var h = Math.ceil(getStackHeight());
    if (!h) return;

    if (!force && Math.abs(h - lastSent) < IGNORE_DELTA_PX) return;
    lastSent = h;

    try {
      window.parent.postMessage(
        { type: "paw_iframe_height_request_v1", height: h },
        "*"
      );
    } catch (_) {}
  }

  function schedule(force) {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(function () {
      rafPending = false;
      postHeight(!!force);
    });
  }

  // Initial + delayed passes (fonts/images/layout settle)
  schedule(true);
  setTimeout(function(){ schedule(true); }, 120);
  setTimeout(function(){ schedule(true); }, 450);

  // Watch DOM mutations (chat streaming, message inserts, etc.)
  try {
    var mo = new MutationObserver(function () { schedule(false); });
    mo.observe(document.body, { childList: true, subtree: true, characterData: true });
  } catch (_) {}

  // Images loading after DOM insert
  document.addEventListener("load", function (e) {
    try { if (e.target && e.target.tagName === "IMG") schedule(false); } catch (_) {}
  }, true);

  // Resize/orientation/keyboard changes: do a forced re-measure
  window.addEventListener("resize", function () { schedule(true); });

})();
</script>
</body>
</html>
